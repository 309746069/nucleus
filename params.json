{"name":"Nucleus","tagline":"Nucleus is an Android library which helps to use the Model-View-Presenter pattern","body":"### The Model-View-Presenter pattern\r\n\r\n* **Model** is a data access layer such as a database API or a remote server API.\r\n* **View** is a layer that displays data and reacts to user actions.\r\nOn Android, this could be an Activity or an android.view.View.\r\n* **Presenter** is a layer that provides View with data from the Model.\r\nPresenter is doing job related to background tasks and data changes.\r\n\r\n![](nucleus-images/nucleus_1.png)\r\n\r\nMore on MVP you can find at\r\n[Wikipedia: Model-View-Presenter](http://en.wikipedia.org/wiki/Model%E2%80%93view%E2%80%93presenter)\r\n\r\n### Inspiration\r\n\r\n[Advocating Against Android Fragments](http://corner.squareup.com/2014/10/advocating-against-android-fragments.html)\r\n\r\n[Mortar](https://github.com/square/mortar)\r\n\r\n[Keep It Stupid Simple](http://people.apache.org/~fhanik/kiss.html)\r\n\r\n# Problem\r\n\r\n* Android development is View-centric\r\n* View cannot be considered as a point of stability for an application because of its nonpermanent nature\r\n* Most of the modern Android applications just use View-Model architecture\r\n* Programmers are involved into fight with View complexities instead of solving business tasks\r\n\r\nUsing only Model-View in your application, you usually end up with \"everything is connected with everything\".\r\n\r\n![](nucleus-images/everything_is_connected_with_everything.png)\r\n\r\nIf this diagram does not look complex, then think about each arrow shows asynchronous data transfer. Each View \r\ncan disappear and appear at random time. Do not forget about saving/restoring of Views.\r\nAttach a couple of background threads to that nonpermanent Views, and the cake is ready!\r\n\r\nAn alternative to the \"everything is connected with everything\" is a God object.\r\n\r\n![](nucleus-images/a_god_object.png)\r\n\r\nA God object is overcomplicated; its parts cannot be reused, tested or easily refactored.\r\n\r\n# Solution: MVC\r\n\r\n![](nucleus-images/mvp.png)\r\n\r\n* Complex tasks are split into simpler tasks and are easier to solve\r\n* Less code, less bugs, easier to debug\r\n* Testable\r\n\r\nWith Nucleus You can use an Activity or a custom Layout to be your View in MVP. You can extend the Fragment class\r\nbut I would advise you against doing that.\r\n\r\n# Simplicity\r\n\r\nDuring the development of the Nucleus the primary goal was to create an MVP solution \r\nfor Android with \"Keep It Stupid Simple\" in mind.\r\nThere are about 15Kb of `nucleus.jar` that do all the job.\r\n(Update: it is 29Kb now but now we have RxJava support!)\r\n\r\nIf you are familiar with the Mortar library you will find a lot of common.\r\nHowever, Nucleus requires you to write less code. You can use the Dagger for your dependencies,\r\nbut it is not used for instantiating a Presenter.\r\n\r\nOne of the shining features of the Nucleus is its Model part of the MVP.\r\nOther MVP solutions are, in fact, 'View-Presenter', and leave Presenter without support from the backside.\r\n\r\n### Hello world\r\n\r\n    public class MainActivity extends NucleusActivity<MainPresenter> {\r\n        @Override\r\n        protected PresenterCreator<MainPresenter> getPresenterCreator() {\r\n            return new PresenterCreator<MainPresenter>() {\r\n                @Override\r\n                public MainPresenter createPresenter() {\r\n                    return new MainPresenter();\r\n                }\r\n            };\r\n        }\r\n    }\r\n\r\n    public class MainPresenter extends Presenter<MainActivity> {\r\n        @Override\r\n        protected void onTakeView(MainActivity view) {\r\n            view.setTitle(\"Hello, MVP world!\");\r\n        }\r\n    }\r\n\r\nIf you care about your existing Activity class tree - you don't have to use the \r\nNucleusActivity class. You can just copy-paste NucleusActivity's code.\r\n\r\n### Loader\r\n\r\nLoader is a simple class that provides a Presenter with data when the data is available. \r\nIt implements the [Observer](http://en.wikipedia.org/wiki/Observer_pattern) and\r\nthe [Adapter](http://en.wikipedia.org/wiki/Adapter_pattern) patterns at the same time.\r\nIt adopts different ways of getting data (database API, network API, cache API etc.) to fit\r\nNucleus and Android components' lifecycle.\r\n\r\n    public abstract class Loader<ResultType> {\r\n\r\n        public interface Receiver<ResultType> {\r\n            void onLoadComplete(Loader<ResultType> loader, ResultType data);\r\n        }\r\n\r\n        public void register(Receiver<ResultType> receiver);\r\n        public void unregister(Receiver<ResultType> receiver);\r\n        protected void notifyReceivers(ResultType data);\r\n    }\r\n\r\nA typical Nucleus application subclasses at least one Loader. Subclassing the Loader allows \r\nto avoid a boilerplate code in the future. \r\nExample: [RetrofitLoader](https://github.com/konmik/nucleus/blob/master/nucleus-example/src/main/java/nucleus/example/network/RetrofitLoader.java).\r\n\r\n# Complexity\r\n\r\n**A complex task requires a complex solution... or not?**\r\n\r\nMost of the time you just need to pass some data from a Model to a View, making a couple of \r\nchecks and preparations for the View to make it completely Model-independent. \r\n\r\nYou don't want to deal with registering/unregistering to loaders,\r\nyou don't want to check if a view exists or it is being recreated right now,\r\nyou don't want to check if data from all required loaders is ready to be presented, etc.\r\nAll of these are typical tasks. To be short: you don't want to create a boilerplate code.\r\nSo here is the LoadBroker class that will do all of that for you.\r\n\r\n* A **Broker** is used to connect a Presenter with a View.\r\n* A **LoadBroker** is used to connect a Model with a View.\r\n\r\nYou can think of Broker as a helping class inside of a Presenter.\r\n\r\n### LoadBroker\r\n\r\n![](nucleus-images/nucleus_2.png)\r\n\r\n* **Loader** - Passes data when available\r\n* **Presenter** - Registers to loaders, publishes data when all data from loaders is available and a View is available.\r\nRe-publishes data when the View has been recreated or when new data is available from Loaders.\r\n* **View** - Just shows data\r\n\r\nHow complex a Presenter's code should be?\r\n\r\n    public class MainPresenter extends Presenter<MainActivity> {\r\n\r\n        @Override\r\n        public void onCreate(Bundle savedState) {\r\n            addViewBroker(new LoaderBroker<MainActivity>(itemsLoader) {\r\n                @Override\r\n                protected void onPresent(MainActivity view) {\r\n                    view.publishItems(getData(itemsLoader));\r\n                }\r\n            });\r\n        }\r\n    }\r\n\r\n**LoadBroker** reduces a boilerplate code - it does all register/unregister job for you.\r\n\r\n![](nucleus-images/broker.png)\r\n\r\n### Custom presenter's typical lifecycle\r\n\r\nSometimes it is not enough just to publish a data.\r\n\r\n    public class MyPresenter extends Presenter<ViewType> {\r\n        @Override\r\n        protected void onCreate(Bundle savedState) {\r\n            // initialize the presenter, start background tasks\r\n        }\r\n\r\n        @Override\r\n        protected void onTakeView(ViewType view) {\r\n            // publish some data when a view is attached to the presenter.\r\n        }\r\n\r\n        // Use getView() to check availability of a view when receiving a background task result.\r\n\r\n        @Override\r\n        protected void onDestroy() {\r\n            // free resources, unregister and cancel background tasks when a user exits a view\r\n        }\r\n    }\r\n\r\n# More Features\r\n\r\n* **Nested presenters** - you can reuse your MVP-driven Views in different application areas,\r\njust override parent presenter's onTakePresenter instead of onTakeView to take control over\r\nthe nested presenter. Alternatively, use the Presenter.addPresenterBroker.\r\n\r\n* **Smart save/restore** - Presenter gets its view AFTER the view has been completely restored \r\nand attached to an Activity. This allows to use View's ability to save and restore its state. \r\nIt is also extremely useful when dealing with user input such as EditText.\r\n\r\n* **RxJava support** - version 0.2 comes with RxJava support - use RxPresenter.\r\n\r\n# How to use\r\n\r\n* Maven dependency:\r\n```\r\n<dependencies>\r\n    <dependency>\r\n        <groupId>info.android15.nucleus</groupId>\r\n        <artifactId>nucleus</artifactId>\r\n        <version>0.2</version>\r\n    </dependency>\r\n</dependencies>\r\n```\r\n\r\n* Gradle dependency:\r\n\r\n```\r\ndependencies {\r\n    compile 'info.android15.nucleus:nucleus:0.2'\r\n}\r\n```\r\n\r\n### Compiled example\r\n* [nucleus-example-0.2.apk](https://repo1.maven.org/maven2/info/android15/nucleus/nucleus-example/0.2/nucleus-example-0.2.apk)\r\n\r\n# Future releases\r\n\r\n* Additional tests\r\n* Improved example\r\n* Contact me if you need more! sirstripy-at-gmail.com","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}