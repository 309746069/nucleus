<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <title>Nucleus by konmik</title>

    <link rel="stylesheet" href="stylesheets/styles.css">
    <link rel="stylesheet" href="stylesheets/pygment_trac.css">
    <script src="javascripts/scale.fix.js"></script>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
  </head>
  <body>
    <div class="wrapper">
      <header>
        <h1 class="header">Nucleus</h1>
        <p class="header">Nucleus is an Android library which helps to use the Model-View-Presenter pattern</p>

        <ul>
          <li class="download"><a class="buttons" href="https://github.com/konmik/nucleus/zipball/master">Download ZIP</a></li>
          <li class="download"><a class="buttons" href="https://github.com/konmik/nucleus/tarball/master">Download TAR</a></li>
          <li><a class="buttons github" href="https://github.com/konmik/nucleus">View On GitHub</a></li>
        </ul>

        <p class="header">This project is maintained by <a class="header name" href="https://github.com/konmik">konmik</a></p>


      </header>
      <section>
        <h3>
<a id="the-model-view-presenter-pattern" class="anchor" href="#the-model-view-presenter-pattern" aria-hidden="true"><span class="octicon octicon-link"></span></a>The Model-View-Presenter pattern</h3>

<ul>
<li>
<strong>View</strong> is a layer that displays data and reacts to user actions.
On Android, this could be Activity or android.view.View.</li>
<li>
<strong>Model</strong> is a data access layer such as database API or remote server API.</li>
<li>
<strong>Presenter</strong> is a layer that provides View with data from Model.
Presenter is doing job related to background tasks and data changes.</li>
</ul>

<p><img src="nucleus-images/nucleus_1.png" alt=""></p>

<p>More on MVP you can find at
<a href="http://en.wikipedia.org/wiki/Model%E2%80%93view%E2%80%93presenter">Wikipedia: Model-View-Presenter</a></p>

<h3>
<a id="inspiration" class="anchor" href="#inspiration" aria-hidden="true"><span class="octicon octicon-link"></span></a>Inspiration</h3>

<p><a href="http://corner.squareup.com/2014/10/advocating-against-android-fragments.html">Advocating Against Android Fragments</a></p>

<p><a href="https://github.com/square/mortar">Mortar</a></p>

<p><a href="http://people.apache.org/%7Efhanik/kiss.html">Keep It Stupid Simple</a></p>

<h1>
<a id="problem" class="anchor" href="#problem" aria-hidden="true"><span class="octicon octicon-link"></span></a>Problem</h1>

<ul>
<li>Android development is View-centric</li>
<li>View cannot be considered as a point of stability for an application because of its nonpermanent nature</li>
<li>Most of the modern Android applications just use View-Model architecture</li>
<li>Programmers are involved into fight with View complexities instead of solving business tasks</li>
</ul>

<p>Using only Model-View in your application you usually end up with "everything is connected with everything".</p>

<p><img src="nucleus-images/everything_is_connected_with_everything.png" alt=""></p>

<p>If this diagram does not look complex, then think about each arrow shows asynchronous data transfer. Each View 
can disappear and appear at random time. Do not forget about saving/restoring of Views.
Attach a couple of background threads to that nonpermanent Views, and the cake is ready!</p>

<p>An alternative to the "everything is connected with everything" is a god object.</p>

<p><img src="nucleus-images/a_god_object.png" alt=""></p>

<p>A god object is overcomplicated; its parts cannot be reused, tested or easily refactored.</p>

<h1>
<a id="solution-mvc" class="anchor" href="#solution-mvc" aria-hidden="true"><span class="octicon octicon-link"></span></a>Solution: MVC</h1>

<p><img src="nucleus-images/mvp.png" alt=""></p>

<ul>
<li>Background tasks persist despite of configuration changes (don't have to check if such task is already running,
no double task runs, no memory leaks - all happens naturally)</li>
<li>Complex tasks are split into simpler tasks and are easier to solve</li>
<li>Less code, less bugs, easier to debug</li>
<li>Testable</li>
</ul>

<h1>
<a id="simplicity" class="anchor" href="#simplicity" aria-hidden="true"><span class="octicon octicon-link"></span></a>Simplicity</h1>

<p>During the development of Nucleus the primary goal was to create an MVP solution 
for Android with "Keep It Stupid Simple" in mind.
There are about 15Kb of <code>nucleus.jar</code> that do all the job.
(0.2 update: it is 29Kb now but now we have RxJava support!)</p>

<p>If you are familiar with Mortar, you will find a lot of common.
However, Nucleus requires you to write less code. You can use Dagger for your dependencies,
but it is not used for instantiating a Presenter.</p>

<p>One of the shining features of Nucleus is its Model part of the MVP.
Other MVP solutions are, in fact 'View-Presenter', and leave Presenter without support from the backside.</p>

<h3>
<a id="hello-world" class="anchor" href="#hello-world" aria-hidden="true"><span class="octicon octicon-link"></span></a>Hello world</h3>

<pre><code>public class MainActivity extends NucleusActivity&lt;MainPresenter&gt; {
    @Override
    protected PresenterCreator&lt;MainPresenter&gt; getPresenterCreator() {
        return new PresenterCreator&lt;MainPresenter&gt;() {
            @Override
            public MainPresenter createPresenter() {
                return new MainPresenter();
            }
        };
    }
}

public class MainPresenter extends Presenter&lt;MainActivity&gt; {
    @Override
    protected void onTakeView(MainActivity view) {
        view.setTitle("Hello, MVP world!");
    }
}
</code></pre>

<p>If you care about your existing Activity class tree - you don't need to use
NucleusActivity class, just copy-paste NucleusActivity's code.</p>

<h3>
<a id="loader" class="anchor" href="#loader" aria-hidden="true"><span class="octicon octicon-link"></span></a>Loader</h3>

<p>Loader is a simple class that provides a Presenter with data when the data is available. 
It implements <a href="http://en.wikipedia.org/wiki/Observer_pattern">Observer</a> and
<a href="http://en.wikipedia.org/wiki/Adapter_pattern">Adapter</a> patterns at the same time.
It adopts different ways of getting data (database API, network API, cache API etc.) to fit
Nucleus and Android components' lifecycle.</p>

<pre><code>public abstract class Loader&lt;ResultType&gt; {

    public interface Receiver&lt;ResultType&gt; {
        void onLoadComplete(Loader&lt;ResultType&gt; loader, ResultType data);
    }

    public void register(Receiver&lt;ResultType&gt; receiver);
    public void unregister(Receiver&lt;ResultType&gt; receiver);
    protected void notifyReceivers(ResultType data);
}
</code></pre>

<p>A typical Nucleus application subclasses Loader at least once. Subclassing Loader allows 
to avoid a boilerplate code in the future. 
Example: <a href="https://github.com/konmik/nucleus/blob/master/nucleus-example/src/main/java/nucleus/example/network/RetrofitLoader.java">RetrofitLoader</a>.</p>

<p>It is also possible to use RxJava for Model, see below.</p>

<h1>
<a id="complexity" class="anchor" href="#complexity" aria-hidden="true"><span class="octicon octicon-link"></span></a>Complexity</h1>

<p><strong>A complex task requires a complex solution... or not?</strong></p>

<p>Most of the time you just need to pass some data from a Model to a View, making a couple of 
checks and preparations for the View to make it completely Model-independent. </p>

<p>You don't want to deal with registering/unregistering to loaders,
you don't want to check if a view exists or it is being recreated right now,
you don't want to check if data from all required loaders is ready to be presented, etc.
All of these are typical tasks. </p>

<p>To be short: you don't want to create a boilerplate code.
So here is LoadBroker class that will do all of that for you.</p>

<ul>
<li>
<strong>Broker</strong> is used to connect a Presenter with a View.</li>
<li>
<strong>LoadBroker</strong> is used to connect a Model with a View.</li>
</ul>

<p>You can think of Broker as a helping class inside of Presenter.</p>

<h3>
<a id="loadbroker" class="anchor" href="#loadbroker" aria-hidden="true"><span class="octicon octicon-link"></span></a>LoadBroker</h3>

<p><img src="nucleus-images/nucleus_2.png" alt=""></p>

<ul>
<li>
<strong>Loader</strong> - Just passes data when data is available</li>
<li>
<strong>View</strong> - Just shows data</li>
<li>
<strong>Presenter</strong> - Registers to loaders, publishes data when all data from loaders is available and a view is available.
Re-publishes data when the view has been recreated or when new data is available from loaders.</li>
</ul>

<p>How complex the Presenter's code should be?</p>

<pre><code>public class MainPresenter extends Presenter&lt;MainActivity&gt; {
    @Override
    public void onCreate(Bundle savedState) {
        addViewBroker(new LoaderBroker&lt;MainActivity&gt;(itemsLoader) {
            @Override
            protected void onPresent(MainActivity view) {
                view.publishItems(getData(itemsLoader));
            }
        });
    }
}
</code></pre>

<p><strong>LoadBroker</strong> does all register/unregister job for you.</p>

<p><img src="nucleus-images/broker.png" alt=""></p>

<p>RxJava variant:</p>

<pre><code>public class MainPresenter extends RxPresenter&lt;MainActivity&gt; {
    @Override
    public void onCreate(Bundle savedState) {
        addRxViewBroker(items.load(), new Action2&lt;List&lt;Item&gt;, MainActivity&gt;() {
            @Override
            public void call(List&lt;Item&gt; items, MainActivity view) {
                view.publishItems(items);
            }
        });
    }
}
</code></pre>

<h3>
<a id="custom-presenters-typical-lifecycle" class="anchor" href="#custom-presenters-typical-lifecycle" aria-hidden="true"><span class="octicon octicon-link"></span></a>Custom presenter's typical lifecycle</h3>

<p>Sometimes it is not enough just to publish data.</p>

<pre><code>public class MyPresenter extends Presenter&lt;ViewType&gt; {
    @Override
    protected void onCreate(Bundle savedState) {
        // initialize the presenter, start background tasks
    }

    @Override
    protected void onTakeView(ViewType view) {
        // publish some data when a view is attached to the presenter.
    }

    // Use getView() to check availability of the view when receiving a background task result.

    @Override
    protected void onDestroy() {
        // free resources, unregister and cancel background tasks when a user exits the view
    }
}
</code></pre>

<h1>
<a id="more-features" class="anchor" href="#more-features" aria-hidden="true"><span class="octicon octicon-link"></span></a>More Features</h1>

<ul>
<li><p><strong>Nested, reusable presenters</strong> - you can reuse your MVP-driven Views in different application areas,
just override parent presenter's onTakePresenter instead of onTakeView if you need to take control over
the nested presenter. Alternatively, use Presenter.addPresenterBroker.</p></li>
<li><p><strong>Smart save/restore</strong> - Presenter gets its view AFTER the view has been completely restored 
and attached to an Activity. This allows to use View's ability to save and restore its state. 
It is also extremely useful when dealing with user input such as EditText.</p></li>
</ul>

<h1>
<a id="how-to-use" class="anchor" href="#how-to-use" aria-hidden="true"><span class="octicon octicon-link"></span></a>How to use</h1>

<ul>
<li>Maven dependency:</li>
</ul>

<pre><code>&lt;dependencies&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;info.android15.nucleus&lt;/groupId&gt;
        &lt;artifactId&gt;nucleus&lt;/artifactId&gt;
        &lt;version&gt;0.2&lt;/version&gt;
    &lt;/dependency&gt;
&lt;/dependencies&gt;
</code></pre>

<ul>
<li>Gradle dependency:</li>
</ul>

<pre><code>dependencies {
    compile 'info.android15.nucleus:nucleus:0.2'
}
</code></pre>

<h3>
<a id="compiled-example" class="anchor" href="#compiled-example" aria-hidden="true"><span class="octicon octicon-link"></span></a>Compiled example</h3>

<ul>
<li><a href="https://repo1.maven.org/maven2/info/android15/nucleus/nucleus-example/0.2/nucleus-example-0.2.apk">nucleus-example-0.2.apk</a></li>
</ul>

<h1>
<a id="future-releases" class="anchor" href="#future-releases" aria-hidden="true"><span class="octicon octicon-link"></span></a>Future releases</h1>

<ul>
<li>Additional tests</li>
<li>Improved example</li>
</ul>

<h1>
<a id="feel-free-to-contact-me" class="anchor" href="#feel-free-to-contact-me" aria-hidden="true"><span class="octicon octicon-link"></span></a>Feel free to contact me</h1>

<p>sirstripy-at-gmail.com</p>
      </section>
      <footer>
        <p><small>Hosted on <a href="http://pages.github.com">GitHub Pages</a> using the Dinky theme</small></p>
      </footer>
    </div>
    <!--[if !IE]><script>fixScale(document);</script><![endif]-->
		
  </body>
</html>
